 /************************************************************************************
* Kalman_Filter.c
* 描述:卡尔曼滤波器
* 所支持的芯片:9S12G128
* 所支持的编译器：CodeWarrior 5.X
* 版权所有：
* 作者：
* 注释：    
* 程序版本：V1.00 
* 更新时间：2012-03-06
*************************************************************************************/

/**************************************卡尔曼规律总结（系数调节）*************************
***首先，保证你输入到程序的角度和角速度是正确的
***其次，保证你的卡尔曼滤波程序是正确的
***再次，才是卡尔曼滤波参数的调整，其参数有三个，
***p0是初始化最优角度估计的协方差（初始化最优角度估计可设为零），
***它是一个初值。Q是预测值的协方差，R是测量值的协方差。对Q和R的设定只需记住，
***Q/(Q+R)的值就是卡尔曼增益的收敛值，比如其值为0.2，
***那么卡尔曼增益会向0.2收敛（对于0.2的含义解释一下，比如预测角度值是5度，
***角度测量值是10度，那么最优化角度为：5+0.2*（10-5）=6。
***从这里可以看出，卡尔曼增益越大，说明测量值越可靠，最优化角度越接近测量值；
***卡尔曼增益越小，说明预测值越可靠，最优化角度越接近预测值）。
***p0/(Q+R)反映收敛的快慢程度，该值设定越小，收敛越快，该值越大，收敛越慢。
***因为卡尔曼增益收敛总的来说是很快的，所以该值设定大一点或小一点都没什么关系。
******************************************************************************************/
#include  "include.h"
#include  "Kalman_Filter.h"

/************************************************************************************
* Kalman_Filter.c
* 描述:卡尔曼滤波器
* 所支持的芯片:9S12XS
* 所支持的编译器：CodeWarrior 5.X
* 版权所有：济南大学智能车工作室
* 作者：    付志博
* 注释：   (第八届光电)矩阵式卡尔曼
* 程序版本：V1.2 
* 更新时间：2013-03-06
*************************************************************************************/

/*********Kalman滤波，8MHz的处理时间约1.8ms***********/

////////////////////////////////////////////
float Angle, Angle_dot; 		//外部需要引用的变量
////////////////////////////////////////////

float Q_angle=0.003, Q_gyro=0.00000007, R_angle=0.3, dt=0.0302;   	//dt的取值为kalman滤波器采样时间;	
/**********************四参数意义***************************************
     Q_angle=0.003, Q_gyro=0.001, R_angle=0.5, dt=0.0342;
太大：太大震荡           过冲               响应慢          无响应、过冲

太小：响应快             没现象             平滑             响应慢
*********************四参数意义****************************************/
float P[2][2] =
            {
				{ 1, 0 },
				{ 0, 1 }
						};
	
char  C_0 = 1;
float E;  
float q_bias=0;
float Angle_err;
float PCt_0, PCt_1;
float K_0, K_1;
float t_0, t_1;
float Pdot[4] ={0,0,0,0};

//-------------------------------------------------------

void Kalman_Filter(float angle_m,float gyro_m)			//gyro_m:gyro_measure
{
	//gyro_m = -gyro_m;
  Angle+=(gyro_m-q_bias) * dt;    //先验估计
	
	Pdot[0]=Q_angle - P[0][1] - P[1][0];// Pk-' 先验估计误差协方差的微分
	Pdot[1]=- P[1][1];
	Pdot[2]=- P[1][1];
	Pdot[3]=Q_gyro;
	
	P[0][0] += Pdot[0] * dt;        // Pk- 先验估计误差协方差微分的积分 = 先验估计误差协方差
	P[0][1] += Pdot[1] * dt;
	P[1][0] += Pdot[2] * dt;
	P[1][1] += Pdot[3] * dt;
		
	Angle_err = angle_m - Angle;    //zk-先验估计
		
	PCt_0 = C_0 * P[0][0];
	PCt_1 = C_0 * P[1][0];
	
	E = R_angle + C_0 * PCt_0;
	
	K_0 = PCt_0 / E;                //Kk
	K_1 = PCt_1 / E;
	
	t_0 = PCt_0;
	t_1 = C_0 * P[0][1];

	P[0][0] -= K_0 * t_0;           //后验估计误差协方差
	P[0][1] -= K_0 * t_1;
	P[1][0] -= K_1 * t_0;
	P[1][1] -= K_1 * t_1;
		
	Angle	 += K_0 * Angle_err;       //后验估计	
	q_bias   += K_1 * Angle_err;       //后验估计
	//Angle_dot = Angle/dt;
	Angle_dot = gyro_m-q_bias;      //输出值（后验估计）的微分 = 角速度
}



/*平滑处理*/
//-------------------------------------------------------
//static float angle,angle_dot; 		//外部需要引用的变量
//-------------------------------------------------------	
//static float bias_cf;
//static const float dt=0.01;
//-------------------------------------------------------
void complement_filter(float angle_m_cf,float gyro_m_cf)
{
///	bias_cf*=0.998;			//陀螺仪零飘低通滤波；500次均值；
//	bias_cf+=gyro_m_cf*0.002;
	Angle_dot=gyro_m_cf;
	//angle=angle+angle_dot*dt;
	Angle=(Angle+Angle_dot*dt)*0.98+angle_m_cf*0.02;	
	//加速度低通滤波；20次均值；按100次每秒计算，低通5Hz；
}
