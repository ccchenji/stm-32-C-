/*---------------------------------------------------------------
						摇摇棒例程

接口：D1-D8  	对应	P1.0-P1.7
      D9-D16 	对应 	P2.7-P2.0
	  水银开关  对应 	INT1 P3.3
	  按键	    对应 	INT0 P3.2

				大学生电子创新创业实践基地
---------------------------------------------------------------*/
#include <reg52.h>
#define uchar unsigned char
#define uint unsigned int    //宏定义

sbit KEY=P3^2;      //定义画面切换按键	// 水银开关  P33 按键 p32
uchar KY;    		//KY作用在后面说明     
uchar disp=0;       //显示汉字指针
uchar pic=0,num=0;     //pic为按键次数；num为中断次数

uchar code text[] = {

0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x40,0x02,0x40,0xFE,0x7F,
0x00,0x40,0x00,0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x40,0x02,0x40,0xFE,0x7F,
0x00,0x40,0x00,0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x70,0x00,
0xF8,0x00,0xFC,0x01,0xFE,0x03,0xFE,0x07,0xFE,0x0F,0xFC,0x1F,0xF8,0x3F,0xF0,0x7F,
0xF0,0xFF,0xF0,0x7F,0xF8,0x3F,0xFC,0x1F,0xFE,0x0F,0xFE,0x07,0xFE,0x03,0xFC,0x01,
0xF8,0x00,0x70,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x40,0x02,0x40,0xFE,0x7F,
0x00,0x40,0x00,0x40,0x00,0x00,0x02,0x7F,0x02,0x41,0x02,0x41,0x02,0x41,0xFE,0x41,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,/*"?????",0*/

};



uchar code text2[] = {


0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x40,0x02,0x40,0xFE,0x7F,
0x00,0x40,0x00,0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x40,0x02,0x40,0xFE,0x7F,
0x00,0x40,0x00,0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x70,0x00,
0xF8,0x00,0xFC,0x01,0xFE,0x03,0xFE,0x07,0xFE,0x0F,0xFC,0x1F,0xF8,0x3F,0xF0,0x7F,
0xF0,0xFF,0xF0,0x7F,0xF8,0x3F,0xFC,0x1F,0xFE,0x0F,0xFE,0x07,0xFE,0x03,0xFC,0x01,
0xF8,0x00,0x70,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x40,0x02,0x40,0xFE,0x7F,
0x00,0x40,0x00,0x40,0x00,0x00,0x02,0x7F,0x02,0x41,0x02,0x41,0x02,0x41,0xFE,0x41,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,/*"?????",0*/
 };

uchar code loveyou[] = {

0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x40,0x02,0x40,0xFE,0x7F,
0x00,0x40,0x00,0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x40,0x02,0x40,0xFE,0x7F,
0x00,0x40,0x00,0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x70,0x00,
0xF8,0x00,0xFC,0x01,0xFE,0x03,0xFE,0x07,0xFE,0x0F,0xFC,0x1F,0xF8,0x3F,0xF0,0x7F,
0xF0,0xFF,0xF0,0x7F,0xF8,0x3F,0xFC,0x1F,0xFE,0x0F,0xFE,0x07,0xFE,0x03,0xFC,0x01,
0xF8,0x00,0x70,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x40,0x02,0x40,0xFE,0x7F,
0x00,0x40,0x00,0x40,0x00,0x00,0x02,0x7F,0x02,0x41,0x02,0x41,0x02,0x41,0xFE,0x41,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,/*"?????",0*/
};

uchar code picture[] = {


0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x40,0x02,0x40,0xFE,0x7F,
0x00,0x40,0x00,0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x40,0x02,0x40,0xFE,0x7F,
0x00,0x40,0x00,0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x70,0x00,
0xF8,0x00,0xFC,0x01,0xFE,0x03,0xFE,0x07,0xFE,0x0F,0xFC,0x1F,0xF8,0x3F,0xF0,0x7F,
0xF0,0xFF,0xF0,0x7F,0xF8,0x3F,0xFC,0x1F,0xFE,0x0F,0xFE,0x07,0xFE,0x03,0xFC,0x01,
0xF8,0x00,0x70,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x40,0x02,0x40,0xFE,0x7F,
0x00,0x40,0x00,0x40,0x00,0x00,0x02,0x7F,0x02,0x41,0x02,0x41,0x02,0x41,0xFE,0x41,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,/*"?????",0*/
};
/*****函数声明*****/
void display_ltor(void);
void display2_ltor(void);
void display3(void);
void display4(void);

/*****n（us）延时子程序*****/
void DelayUs(uint N)
{
 uint x;
 for(x=0; x<=1*N;x++);
}

/*****中断服务程序*****/
void intersvr0(void) interrupt 2 
{
 KY=~KY;      //每个摇动来回水银开关会在摆幅两端分别产生下降沿中断，只提取其中一次（从左向右摇才显示）
 if(KY==0)
 {
   num++;     //计算中断次数
   switch(pic)      //选择画面
   {   case 0:{display_ltor();}break;
       case 1:{display2_ltor();}break;
       case 2:{display3();}break;
	   case 3:{display4();}break;
       default:{display2_ltor();}  
   }
 }
}

void display_ltor(void)
{

uchar i;
uchar d;
 if(num>5){disp++;num=0;}     //12个汉字分为3次显示完（每次显示4个），每中断10次切换
 if(disp>1)disp=0;
  DelayUs(5300);     //此处延时时间依各硬件差别而各不相同，试着调整使得显示内容居中即可
 for(i=0;i<64;i++)
 {
     d= ~text[disp*128+i*2+1];
     P2=~text[disp*128+i*2];
	 d=((d<<4)|(d>>4));
	 d=(((d<<2)&0xcc)|((d>>2)&0x33));
	 d=(((d<<1)&0xaa)|((d>>1)&0x55));
     P0=d;
     DelayUs(120);
 }

}
void display2_ltor(void)
{

uchar i;
uchar d;
 if(num>5){disp++;num=0;}     //12个汉字分为3次显示完（每次显示4个），每中断10次切换
 if(disp>2)disp=0;
  DelayUs(5300);     //此处延时时间依各硬件差别而各不相同，试着调整使得显示内容居中即可
 for(i=0;i<64;i++)
 {
     d= ~text2[disp*128+i*2+1];
     P2=~text2[disp*128+i*2];
	 d=((d<<4)|(d>>4));
	 d=(((d<<2)&0xcc)|((d>>2)&0x33));
	 d=(((d<<1)&0xaa)|((d>>1)&0x55));
     P0=d;
     DelayUs(120);
 }

}
/*****显示子程序3（心形图案）*****/
void display3(void)
{
 uchar i;
  uchar d;
  DelayUs(5200);
 for(i=0;i<64;i++)
 {	 
     d=~loveyou[i*2+1];
     P2=~loveyou[i*2];
	 d=((d<<4)|(d>>4));
	 d=(((d<<2)&0xcc)|((d>>2)&0x33));
	 d=(((d<<1)&0xaa)|((d>>1)&0x55));
     P0=d;
     DelayUs(120);
 }
}

void display4(void)
{

uchar i;
uchar d;
 if(num>2){disp++;num=0;}     //12个汉字分为3次显示完（每次显示4个），每中断10次切换
 if(disp>1)disp=0;
  DelayUs(5300);     //此处延时时间依各硬件差别而各不相同，试着调整使得显示内容居中即可
 for(i=0;i<64;i++)
 {
     d= ~picture[disp*96+i*2+1];
     P2=~picture[disp*96+i*2];
	 d=((d<<4)|(d>>4));
	 d=(((d<<2)&0xcc)|((d>>2)&0x33));
	 d=(((d<<1)&0xaa)|((d>>1)&0x55));
     P0=d;
     DelayUs(120);
 }

}
/*****主函数*****/
void main(void)
{
 IT1=1;
 EX1=1;
 EA=1;      //开中断，下降沿中断
 KY=0;
 KEY=1;
 while(1)     //主程序中只检测按键
 {
  if(KEY==0)     //画面切换键按下
  {
     DelayUs(5000);     //按键去抖
     if(KEY==0);
     pic++;
     while(KEY==0);
  }
  if(pic>3)pic=0;
 }
}
/*****END*****/

	